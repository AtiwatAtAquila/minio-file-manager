
# เอกสารข้อกำหนดผลิตภัณฑ์ (PRD) สำหรับ MinIO Admin Backend MVP

## เป้าหมายและที่มา

### เป้าหมาย
- สร้างระบบจัดการไฟล์ที่ปลอดภัยและควบคุมสิทธิ์การเข้าถึง (RBAC) บนพื้นที่จัดเก็บข้อมูล MinIO
- พัฒนา REST API ที่พร้อมใช้งานจริงสำหรับการจัดการไฟล์ด้วย RBAC
- ผสานการทำงานเข้ากับโครงสร้างพื้นฐาน Caddy forward_auth ที่มีอยู่ได้อย่างไร้รอยต่อ
- ส่งมอบ API ที่ใช้งานง่ายสำหรับนักพัฒนา พร้อมเอกสาร OpenAPI ในตัว
- รองรับการนำไปใช้ร่วมกับแอปพลิเคชันอื่นได้อย่างรวดเร็ว (ภายใน 1 วัน)
- ยังคงหลักการออกแบบที่สามารถติดตั้งเองได้และไม่ผูกติดกับผู้ให้บริการคลาวด์รายใด

### ที่มา
MinIO เป็น Object Storage ที่ยอดเยี่ยม แต่ขาดระบบควบคุมสิทธิ์การเข้าถึงแบบละเอียดสำหรับงานบริหารจัดการ ทำให้หลายองค์กรต้องเผชิญกับความท้าทายเรื่องการกำหนดสิทธิ์ระดับไฟล์ การผสานระบบยืนยันตัวตนที่ซับซ้อน และการขาดบันทึกการตรวจสอบ (Audit Trail) บริการนี้จึงถูกสร้างขึ้นมาเพื่อเป็น "ตัวกลางอัจฉริยะ" ระหว่างแอปพลิเคชันกับ MinIO โดยเพิ่มการจัดการข้อมูลเมตาที่เก็บในฐานข้อมูล, ระบบ RBAC ที่เน้นความปลอดภัยเป็นอันดับแรก, และการออกแบบ API ที่เป็นมิตรกับนักพัฒนา

โซลูชันนี้จะเข้ามาเติมเต็มช่องว่างระหว่างความสามารถระดับโครงสร้างพื้นฐานของ MinIO กับความต้องการควบคุมการเข้าถึงระดับแอปพลิเคชัน ทำให้อองค์กรสามารถใช้ประโยชน์จากความน่าเชื่อถือของ MinIO ได้อย่างเต็มที่ พร้อมกับเพิ่มการจัดการสิทธิ์ระดับองค์กรเข้าไป

### บันทึกการเปลี่ยนแปลง

| วันที่ | เวอร์ชัน | คำอธิบาย | ผู้เขียน |
|---|---|---|---|
| 2024-12-19 | 1.0 | สร้าง PRD ฉบับแรกจากข้อมูลสรุปโครงการ | Product Manager John |

---

## ข้อกำหนด

### ด้านฟังก์ชัน (Functional)

**FR1**: ระบบจะต้องดึงข้อมูลผู้ใช้จากส่วนหัว (Header) ของ Caddy forward_auth (x-user-id, x-user-email, x-user-roles) สำหรับทุกคำขอ API
**FR2**: ระบบจะต้องแสดงรายการไฟล์แบบแบ่งหน้า (Pagination) พร้อมข้อมูลเมตา (ชื่อไฟล์, ประเภท, วันที่อัปโหลด, ขนาด) ที่เก็บไว้ในฐานข้อมูล PostgreSQL
**FR3**: ระบบจะต้องสร้าง URL ที่มีการลงชื่อล่วงหน้า (Presigned URL) ของ MinIO ซึ่งมีอายุ 5 นาทีสำหรับอัปโหลดไฟล์อย่างปลอดภัย
**FR4**: ระบบจะต้องมีฟังก์ชันค้นหาไฟล์จากชื่อไฟล์โดยใช้ Prisma
**FR5**: ระบบจะต้องควบคุมการเข้าถึงตามบทบาท (Role-based access control) โดยให้ผู้ใช้เห็นเฉพาะไฟล์ที่บทบาทของตนเองมีสิทธิ์เท่านั้น
**FR6**: ระบบจะต้องรองรับการจัดการบทบาท (Roles) แบบ CRUD (สร้าง, อ่าน, อัปเดต, ลบ)
**FR7**: ระบบจะต้องกำหนดให้เฉพาะผู้ใช้ที่มีบทบาท **"Boss"** เท่านั้นที่สามารถสร้างบทบาทใหม่ได้
**FR8**: ระบบจะต้องมีการจัดการสิทธิ์ไฟล์ที่อนุญาตให้กำหนดหรือยกเลิกสิทธิ์การเข้าถึงไฟล์เฉพาะเจาะจงแก่บทบาทต่าง ๆ ได้
**FR9**: ระบบจะต้องยึดหลักความปลอดภัยเป็นอันดับแรก โดยไฟล์ที่อัปโหลดใหม่จะเข้าถึงได้เฉพาะผู้ที่มีบทบาทเดียวกับผู้อัปโหลดเท่านั้นในตอนแรก
**FR10**: ระบบจะต้องเปิดเผยข้อมูล API ทั้งหมดผ่าน endpoint `OpenAPI.json` พร้อมด้วยอินเทอร์เฟซเอกสารของ Scalar
**FR11**: ระบบจะต้องตรวจสอบข้อมูลเมตาไฟล์ (ชื่อไฟล์, ประเภท) ระหว่างการสร้างบันทึกไฟล์ ก่อนที่จะสร้าง Presigned URL
**FR12**: ระบบจะต้องรักษาความสมบูรณ์ของข้อมูลอ้างอิงระหว่างตาราง `Files`, `Roles` และ `FileRolePermissions` โดยใช้ Prisma ORM
**FR13**: ระบบจะต้องมี endpoint สำหรับแสดงรายการไฟล์ทั้งหมดที่บทบาทใดบทบาทหนึ่งสามารถเข้าถึงได้

### ด้านไม่ใช่ฟังก์ชัน (Non Functional)

**NFR1**: ระบบจะต้องส่งคืนข้อผิดพลาด HTTP 500 ที่เหมาะสมเมื่อบริการ MinIO ไม่พร้อมใช้งาน เพื่อให้ส่วนหน้า (Frontend) สามารถลองส่งคำขอใหม่ได้
**NFR2**: ระบบจะต้องใช้การจัดการ CORS ที่มีในเฟรมเวิร์ก ElysiaJS สำหรับคำขอที่มาจากต่างโดเมน
**NFR3**: ระบบจะต้องสามารถติดตั้งในรูปแบบ Docker Container เดียวได้ โดยมีส่วนประกอบภายนอกที่จำเป็นคือ PostgreSQL, Redis และ MinIO
**NFR4**: ระบบจะต้องมีการตรวจสอบและกรองข้อมูลนำเข้าที่เหมาะสมสำหรับทุก endpoint ของ API
**NFR5**: ระบบจะต้องถูกพัฒนาด้วยภาษา TypeScript เพื่อให้มั่นใจในความปลอดภัยของประเภทข้อมูลตลอดทั้งโค้ด
**NFR6**: ระบบจะต้องออกแบบตามหลักการ RESTful API โดยมีรูปแบบการตอบกลับที่สอดคล้องกัน

---

## ข้อสมมติทางเทคนิค

### โครงสร้างพื้นที่เก็บข้อมูล: Monorepo
ใช้โครงสร้าง repository เดียวเพื่อความเรียบง่ายของ MVP และมีการแยกส่วนภายใน (Internal Module) ที่ชัดเจน

### สถาปัตยกรรมบริการ
**Monolith**: ใช้บริการ ElysiaJS เพียงตัวเดียวที่มีสถาปัตยกรรมภายในแบบโมดูลาร์ เพื่อการพัฒนาและติดตั้งที่รวดเร็ว

### ข้อกำหนดการทดสอบ
**Unit Test เท่านั้น**: ทดสอบเฉพาะส่วนของตรรกะทางธุรกิจและฟังก์ชันหลัก ไม่จำเป็นต้องมีการทดสอบแบบรวมระบบ (Integration) หรือแบบ E2E (End-to-End) สำหรับ MVP นี้

### ข้อสมมติและข้อกำหนดทางเทคนิคเพิ่มเติม
**สภาพแวดล้อมการรัน (Runtime)**: Bun เนื่องจากรองรับ TypeScript เวอร์ชันล่าสุด, ประสิทธิภาพที่ดี, และเข้ากันได้ดีเยี่ยมกับ ElysiaJS
**ORM ฐานข้อมูล**: Prisma คู่กับ PostgreSQL เพื่อการจัดการฐานข้อมูลที่ปลอดภัยเรื่องประเภทข้อมูลและการทำ Migration อัตโนมัติ
**เฟรมเวิร์ก API**: ElysiaJS ที่มีระบบสร้างเอกสาร OpenAPI และอินเทอร์เฟซ Scalar ในตัว
**Object Storage**: ใช้ MinIO SDK สำหรับการสร้าง Presigned URL และการจัดการพื้นที่จัดเก็บ
**เลเยอร์แคช**: Redis สำหรับการเพิ่มประสิทธิภาพการสืบค้นข้อมูลเมตาไฟล์ (ถ้าจำเป็น)
**การผสานระบบยืนยันตัวตน**: ดึงข้อมูลจากส่วนหัว Caddy forward_auth (x-user-id, x-user-email, x-user-roles) โดยไม่ต้องเขียนโค้ดระบบยืนยันตัวตนเอง
**กลยุทธ์ Container**: ติดตั้งใน Docker Container เดียว โดยการตั้งค่าจะขึ้นอยู่กับ Environment
**สภาพแวดล้อมการพัฒนา**: Docker Compose สำหรับการพัฒนาบนเครื่อง local พร้อมบริการ PostgreSQL, Redis และ MinIO
**กลยุทธ์การจัดการข้อผิดพลาด**: ใช้รหัสสถานะ HTTP แบบง่ายพร้อมกับการตอบกลับแบบ JSON โดยให้ส่วนหน้าเป็นผู้จัดการตรรกะในการลองใหม่ (Retry)
**การตั้งค่า CORS**: ใช้ ElysiaJS built-in CORS middleware
**การตรวจสอบข้อมูลนำเข้า**: ใช้ระบบตรวจสอบข้อมูลของ ElysiaJS ที่รองรับ Schema ของ TypeScript
**ขั้นตอนการอัปโหลดไฟล์**: สร้างบันทึกในฐานข้อมูลก่อน แล้วจึงสร้าง Presigned URL พร้อมตรวจสอบข้อมูลเมตาไฟล์
**โมเดลสิทธิ์**: ยึดหลักความปลอดภัยเป็นหลัก โดยให้สิทธิ์อย่างจำกัดในตอนแรกและต้องมีการกำหนดสิทธิ์เพิ่มเติมอย่างชัดเจน
**การจัดการบทบาท**: ต้องใช้บทบาท "Boss" ในการสร้างบทบาทใหม่ และสามารถจัดการบทบาทอื่น ๆ ได้แบบ CRUD
**Schema ฐานข้อมูล**: ออกแบบเป็น 3 ตาราง (Files, Roles, FileRolePermissions) ที่มีการเชื่อมโยงกันแบบ Foreign Key

---

## รายการ Epic

**Epic 1: โครงสร้างพื้นฐาน** สร้างโครงสร้างโปรเจกต์, Schema ฐานข้อมูล, เฟรมเวิร์ก API พื้นฐาน และสภาพแวดล้อมการพัฒนาด้วย Docker
**Epic 2: การจัดการไฟล์และการเชื่อมต่อ MinIO** พัฒนาการจัดการไฟล์แบบ CRUD, การสร้าง Presigned URL และการเชื่อมต่อกับ MinIO
**Epic 3: ระบบควบคุมสิทธิ์ตามบทบาท (RBAC)** สร้าง API สำหรับการจัดการบทบาท, ระบบสิทธิ์ และการบังคับใช้สิทธิ์ที่ปลอดภัยโดยใช้ข้อมูลจาก Caddy
**Epic 4: เอกสาร API และความพร้อมใช้งานจริง** จัดทำเอกสาร OpenAPI ที่สมบูรณ์, จัดการข้อผิดพลาดและตรวจสอบข้อมูล, และเตรียมพร้อมสำหรับการติดตั้งใช้งานจริง

---

## Epic 1: โครงสร้างพื้นฐาน

**เป้าหมายของ Epic**: สร้างโครงสร้างโปรเจกต์, Schema ฐานข้อมูล, เฟรมเวิร์ก API พื้นฐาน และสภาพแวดล้อมการพัฒนา เพื่อเป็นรากฐานสำหรับงานพัฒนาทั้งหมด

### Story 1.1: ตั้งค่าโปรเจกต์และส่วนประกอบที่จำเป็น

ในฐานะ **นักพัฒนา**
ฉันต้องการ **โปรเจกต์ TypeScript ที่มีการตั้งค่าอย่างถูกต้องพร้อมส่วนประกอบที่จำเป็นครบถ้วน**
เพื่อที่ **ฉันจะได้เริ่มต้นพัฒนาด้วยรากฐานที่มั่นคงและมีเครื่องมือที่จำเป็นทั้งหมด**

#### เกณฑ์การยอมรับ (Acceptance Criteria)
1. โปรเจกต์ Bun เริ่มต้นด้วยการตั้งค่า TypeScript และสคริปต์ที่เหมาะสม (dev, build, start)
2. ติดตั้งและตั้งค่าเฟรมเวิร์ก ElysiaJS พร้อมเซิร์ฟเวอร์พื้นฐาน
3. ติดตั้ง Prisma ORM พร้อมอะแดปเตอร์ PostgreSQL และการตั้งค่าพื้นฐาน
4. ติดตั้ง MinIO SDK และพร้อมสำหรับการเชื่อมต่อ
5. ตั้งค่าส่วนประกอบสำหรับการพัฒนาทั้งหมด (TypeScript, type definitions, linting)
6. สร้างสคริปต์ใน `Package.json` สำหรับเวิร์กโฟลว์การพัฒนา (dev, build, test, db:migrate)
7. สร้างโครงสร้างโปรเจกต์พื้นฐานที่มีไดเรกทอรี `src/` และไฟล์หลัก
8. สร้างไฟล์ `.env.example` ที่มีตัวแปรการตั้งค่าที่จำเป็น

### Story 1.2: Schema ฐานข้อมูลและการตั้งค่า Prisma

ในฐานะ **นักพัฒนา**
ฉันต้องการ **Schema ฐานข้อมูลที่สมบูรณ์พร้อมการตั้งค่า Prisma ORM**
เพื่อที่ **ฉันจะได้สามารถจัดการฐานข้อมูลไฟล์, บทบาท และสิทธิ์ได้อย่างปลอดภัยเรื่องประเภทข้อมูล**

#### เกณฑ์การยอมรับ
1. กำหนด Schema ของ Prisma ที่มีตาราง `Files` (id, filename, filetype, fileSize, uploadedAt, minioKey)
2. Schema ของ Prisma มีตาราง `Roles` (id, name, createdAt, updatedAt)
3. Schema ของ Prisma มีตารางเชื่อมโยง `FileRolePermissions` (fileId, roleName, grantedAt)
4. ไฟล์ Migration ของฐานข้อมูลถูกสร้างและนำไปใช้สำเร็จ
5. Prisma client ถูกสร้างพร้อมประเภทข้อมูล TypeScript สำหรับทุกโมเดล
6. ความสัมพันธ์แบบ Foreign key ถูกตั้งค่าอย่างถูกต้องระหว่างทุกตาราง
7. ตั้งค่าการเชื่อมต่อฐานข้อมูลผ่านตัวแปร Environment
8. สร้างสคริปต์ Database Seed สำหรับข้อมูลตัวอย่าง (บทบาท Boss, ข้อมูลตัวอย่าง)

### Story 1.3: สภาพแวดล้อมการพัฒนาด้วย Docker

ในฐานะ **นักพัฒนา**
ฉันต้องการ **สภาพแวดล้อมการพัฒนาด้วย Docker ที่สมบูรณ์**
เพื่อที่ **ฉันจะได้รันแอปพลิเคชันพร้อมส่วนประกอบทั้งหมด (PostgreSQL, Redis, MinIO) บนเครื่อง local**

#### เกณฑ์การยอมรับ
1. สร้าง Dockerfile สำหรับแอปพลิเคชันด้วย Bun runtime และขั้นตอนการ build ที่เหมาะสม
2. ตั้งค่าไฟล์ Docker Compose ด้วยบริการ PostgreSQL, Redis และ MinIO
3. กำหนดค่า Container ของแอปพลิเคชันให้สามารถเชื่อมต่อกับบริการอื่น ๆ ที่จำเป็น
4. ส่งผ่านตัวแปร Environment ไปยัง Container ของแอปพลิเคชันอย่างถูกต้อง
5. ตั้งค่า Volume Mounts เพื่อรองรับการ Hot-reloading โค้ด
6. ระบบเริ่มต้นและ Migration ฐานข้อมูลแบบอัตโนมัติเมื่อ Container เริ่มทำงาน
7. ทุกบริการสามารถเข้าถึงได้ผ่านพอร์ตและการตั้งค่าเครือข่ายที่เหมาะสม
8. อัปเดตเอกสารพร้อมคำแนะนำการตั้งค่าและรัน Docker

### Story 1.4: เฟรมเวิร์ก API พื้นฐานและการตรวจสอบสถานะ

ในฐานะ **นักพัฒนา**
ฉันต้องการ **เซิร์ฟเวอร์ ElysiaJS API ที่ทำงานได้พร้อม endpoint พื้นฐาน**
เพื่อที่ **ฉันจะได้ตรวจสอบว่าแอปพลิเคชันทำงานได้อย่างถูกต้องและเริ่มเพิ่มตรรกะทางธุรกิจได้**

#### เกณฑ์การยอมรับ
1. ตั้งค่าเซิร์ฟเวอร์ ElysiaJS ให้เริ่มทำงานบนพอร์ตที่กำหนดได้ พร้อมการจัดการข้อผิดพลาดที่เหมาะสม
2. Endpoint ตรวจสอบสถานะ (`GET /health`) ส่งคืนสถานะแอปพลิเคชันและการเชื่อมต่อกับส่วนประกอบอื่น ๆ
3. เปิดใช้งานการตั้งค่า CORS พื้นฐานโดยใช้ ElysiaJS built-in middleware
4. ตั้งค่า Middleware สำหรับการบันทึกคำขอ/การตอบกลับสำหรับการพัฒนา
5. ตั้งค่า Middleware สำหรับการจัดการข้อผิดพลาดพื้นฐานเพื่อให้การตอบกลับสอดคล้องกัน
6. ตั้งค่าปลั๊กอิน OpenAPI ด้วยข้อมูลเมตาของแอปพลิเคชันพื้นฐาน
7. สามารถเข้าถึงเอกสาร Scalar ที่ endpoint `/docs`
8. แอปพลิเคชันเริ่มต้นทำงานและตอบสนองต่อคำขอ HTTP ในสภาพแวดล้อม Docker ได้สำเร็จ

---

## Epic 2: การจัดการไฟล์และการเชื่อมต่อ MinIO

**เป้าหมายของ Epic**: พัฒนาการจัดการไฟล์หลัก ๆ ได้แก่ การแสดงรายการ, การจัดการข้อมูลเมตา, การสร้าง Presigned URL และการเชื่อมต่อกับ MinIO เพื่อให้สามารถอัปโหลดและเรียกดูไฟล์ได้อย่างปลอดภัย

### Story 2.1: การจัดการข้อมูลเมตาไฟล์แบบ CRUD

ในฐานะ **นักพัฒนาที่ใช้ API**
ฉันต้องการ **สร้าง, อ่าน, อัปเดต, และลบข้อมูลเมตาของไฟล์**
เพื่อที่ **ฉันจะได้จัดการข้อมูลไฟล์ในฐานข้อมูลทั้งก่อนและหลังการดำเนินการกับ MinIO**

#### เกณฑ์การยอมรับ
1. Endpoint `POST /files` สร้างบันทึกข้อมูลเมตาไฟล์ พร้อมการตรวจสอบชื่อไฟล์และประเภท
2. Endpoint `GET /files/{id}` ส่งคืนข้อมูลเมตาไฟล์ที่สมบูรณ์ รวมถึงสถานะการอัปโหลด
3. Endpoint `PATCH /files/{id}` อัปเดตข้อมูลเมตาไฟล์ (ชื่อ, ประเภท) พร้อมการตรวจสอบ
4. Endpoint `DELETE /files/{id}` ลบบันทึกข้อมูลเมตาไฟล์ และจัดการลบไฟล์ใน MinIO ด้วย
5. ข้อมูลเมตาไฟล์ประกอบด้วย: id, filename, filetype, fileSize, uploadedAt, minioKey
6. การตรวจสอบข้อมูลนำเข้าเพื่อให้แน่ใจว่าชื่อไฟล์ปลอดภัยและประเภทไฟล์อยู่ในรายการที่อนุญาต
7. การดำเนินการฐานข้อมูลใช้ Prisma พร้อมการจัดการข้อผิดพลาดที่เหมาะสม
8. ทุก endpoint ส่งคืนการตอบกลับแบบ JSON ที่สอดคล้องกันพร้อมรหัสสถานะ HTTP ที่ถูกต้อง

### Story 2.2: การเชื่อมต่อ MinIO และ Presigned URL

ในฐานะ **นักพัฒนาส่วนหน้า**
ฉันต้องการ **รับ Presigned URL เพื่อการอัปโหลดไฟล์อย่างปลอดภัย**
เพื่อที่ **ฉันจะได้อัปโหลดไฟล์ตรงไปยัง MinIO ได้โดยไม่ต้องเปิดเผยข้อมูลการเข้าถึงพื้นที่จัดเก็บ**

#### เกณฑ์การยอมรับ
1. Endpoint `POST /files/{id}/presigned-url` สร้าง MinIO Presigned URL ที่มีอายุ 5 นาที
2. การสร้าง Presigned URL รวมถึงการกำหนดค่า Bucket และ Key ของ MinIO ที่ถูกต้อง
3. การตั้งค่าการเชื่อมต่อ MinIO ถูกดึงจากตัวแปร Environment
4. การจัดการข้อผิดพลาดสำหรับกรณีที่บริการ MinIO ไม่พร้อมใช้งานจะส่งคืน HTTP 500 พร้อมข้อความแนะนำให้ลองใหม่
5. การตอบกลับ Presigned URL มี URL สำหรับอัปโหลด, HTTP Method และ Headers ที่จำเป็น
6. ข้อมูลเมตาไฟล์ถูกอัปเดตด้วย MinIO key หลังจากการสร้าง Presigned URL สำเร็จ
7. MinIO SDK ถูกตั้งค่าอย่างถูกต้องพร้อม connection pooling และ timeout
8. Unit Test ครอบคลุมการเชื่อมต่อ MinIO ด้วยการจำลองบริการ MinIO (Mock)

### Story 2.3: การแสดงรายการไฟล์แบบแบ่งหน้าพร้อมการค้นหา

ในฐานะ **ผู้ใช้ API**
ฉันต้องการ **แสดงรายการไฟล์แบบแบ่งหน้าและมีฟังก์ชันค้นหา**
เพื่อที่ **ฉันจะได้สามารถเรียกดูและค้นหาไฟล์ในระบบได้อย่างมีประสิทธิภาพ**

#### เกณฑ์การยอมรับ
1. Endpoint `GET /files` ส่งคืนรายการไฟล์แบบแบ่งหน้าพร้อมขนาดหน้าที่กำหนดได้
2. พารามิเตอร์ Query `?search={filename}` กรองไฟล์ด้วยชื่อไฟล์บางส่วน
3. ข้อมูลการแบ่งหน้าประกอบด้วย: จำนวนทั้งหมด, หน้าปัจจุบัน, จำนวนหน้าทั้งหมด, มีหน้าถัดไป/ก่อนหน้า
4. รายการไฟล์จะถูกจัดเรียงตาม `uploadedAt` (ใหม่สุดก่อน) เป็นค่าเริ่มต้น
5. ฟังก์ชันค้นหาใช้ Prisma ในการสืบค้นฐานข้อมูลพร้อมการใช้ Index ที่เหมาะสม
6. การตอบกลับมีข้อมูลเมตาของไฟล์ทั้งหมดในรูปแบบที่สอดคล้องกัน
7. กรณีที่ไม่มีผลลัพธ์จะส่งคืนโครงสร้างที่ถูกต้องพร้อมอาร์เรย์ว่างและข้อมูลการแบ่งหน้า
8. พารามิเตอร์ Query ถูกตรวจสอบและส่งข้อผิดพลาดที่เหมาะสมหากค่าไม่ถูกต้อง

### Story 2.4: การผสานเวิร์กโฟลว์การอัปโหลดไฟล์

ในฐานะ **นักพัฒนาส่วนหน้า**
ฉันต้องการ **เวิร์กโฟลว์การอัปโหลดไฟล์ที่สมบูรณ์**
เพื่อที่ **ฉันจะได้อัปโหลดไฟล์ด้วยรูปแบบการเรียกใช้ API เพียงครั้งเดียว**

#### เกณฑ์การยอมรับ
1. Endpoint `POST /files` สร้างบันทึกข้อมูลเมตา **และ** ส่งคืน Presigned URL ในการตอบกลับครั้งเดียว
2. รูปแบบการตอบกลับประกอบด้วย: `{id, filename, filetype, presignedUrl, uploadUrl}`
3. บันทึกไฟล์ถูกสร้างในสถานะ "pending" จนกว่าการอัปโหลดจะได้รับการยืนยัน
4. การจัดการข้อผิดพลาดสำหรับชื่อไฟล์ที่ซ้ำกันด้วยรหัสสถานะ HTTP ที่เหมาะสม
5. การตรวจสอบขนาดไฟล์เทียบกับขีดจำกัดที่เหมาะสม (กำหนดได้ผ่าน Environment)
6. การตรวจสอบ Content-Type ให้ตรงกับ `filetype` ที่ระบุในคำขอ
7. การจัดการธุรกรรม (Transaction) เพื่อให้ข้อมูลในฐานข้อมูลสอดคล้องกันหากการดำเนินการ MinIO ล้มเหลว
8. การทดสอบแบบ Integration ครอบคลุมเวิร์กโฟลว์ทั้งหมดตั้งแต่การสร้างบันทึกจนถึงการสร้าง Presigned URL

---

## Epic 3: ระบบควบคุมสิทธิ์ตามบทบาท (RBAC)

**เป้าหมายของ Epic**: พัฒนาระบบควบคุมสิทธิ์ตามบทบาทที่ครอบคลุม รวมถึงการระบุผู้ใช้จาก Header ของ Caddy, การจัดการบทบาท, ระบบสิทธิ์ไฟล์ และการบังคับใช้สิทธิ์ที่เน้นความปลอดภัยเป็นอันดับแรก เพื่อปกป้องไฟล์ตามบทบาทของผู้ใช้

### Story 3.1: การผสานระบบ Header ยืนยันตัวตนของ Caddy

ในฐานะ **System Integrator**
ฉันต้องการ **ให้ API สามารถดึงและตรวจสอบข้อมูลผู้ใช้จาก Header ของ Caddy forward_auth**
เพื่อที่ **ระบบจะได้ระบุผู้ใช้และบทบาทของพวกเขาได้โดยไม่ต้องพัฒนาระบบยืนยันตัวตนแยกต่างหาก**

#### เกณฑ์การยอมรับ
1. Middleware ดึง Header `x-user-id`, `x-user-email`, `x-user-roles` จากทุกคำขอที่เข้ามา
2. บทบาทของผู้ใช้ถูกแยกจาก Header `x-user-roles` ที่คั่นด้วยคอมมา ให้เป็นรูปแบบ Array
3. หาก Header ที่จำเป็นหายไป จะส่งคืน HTTP 401 พร้อมข้อความข้อผิดพลาดที่ชัดเจน
4. หาก Header ผิดรูปแบบหรือไม่ถูกต้อง จะส่งคืน HTTP 400 พร้อมรายละเอียดข้อผิดพลาด
5. ข้อมูลผู้ใช้ (id, email, roles) ถูกแนบไปกับ Request Object สำหรับใช้ใน Route Handler
6. Middleware ถูกนำไปใช้กับทุก Endpoint ที่มีการป้องกัน (ยกเว้น `health check` และ `docs`)
7. Unit Test ครอบคลุมการดึงข้อมูล Header, การตรวจสอบ และกรณีเกิดข้อผิดพลาด
8. การผสานการทำงานกับระบบ Middleware ของ ElysiaJS เพื่อให้การประมวลผลคำขอสอดคล้องกัน

### Story 3.2: การจัดการบทบาทแบบ CRUD

ในฐานะ **ผู้ดูแลระบบ**
ฉันต้องการ **ความสามารถในการจัดการบทบาทที่สมบูรณ์ผ่าน REST API**
เพื่อที่ **ฉันจะได้สร้าง, แก้ไข, และลบบทบาทเพื่อจัดระเบียบสิทธิ์การเข้าถึงไฟล์**

#### เกณฑ์การยอมรับ
1. Endpoint `GET /roles` ส่งคืนรายการบทบาททั้งหมดพร้อมข้อมูลเมตา (id, name, createdAt)
2. Endpoint `POST /roles` สร้างบทบาทใหม่ (จำกัดเฉพาะผู้ใช้ที่มีบทบาท **"Boss"** เท่านั้น)
3. Endpoint `PUT /roles/{id}` อัปเดตชื่อบทบาทพร้อมการตรวจสอบที่เหมาะสม
4. Endpoint `DELETE /roles/{id}` ลบบทบาทและลบสิทธิ์ไฟล์ที่เกี่ยวข้องทั้งหมด
5. การตรวจสอบชื่อบทบาทเพื่อให้แน่ใจว่าไม่ซ้ำและใช้เฉพาะอักขระที่ปลอดภัย
6. การจำกัดสิทธิ์บทบาท Boss ถูกบังคับใช้ผ่าน Middleware ที่ตรวจสอบบทบาทผู้ใช้จาก Header
7. ผู้ใช้ที่ไม่ใช่ Boss จะได้รับ HTTP 403 เมื่อพยายามสร้างบทบาทใหม่
8. การจัดการฐานข้อมูลรองรับการเข้าถึงพร้อมกันและรักษาความสมบูรณ์ของข้อมูลอ้างอิง

### Story 3.3: ระบบการจัดการสิทธิ์ไฟล์

ในฐานะ **เจ้าของไฟล์หรือผู้ดูแลระบบ**
ฉันต้องการ **กำหนดและยกเลิกสิทธิ์การเข้าถึงไฟล์เฉพาะเจาะจงตามบทบาท**
เพื่อที่ **ฉันจะได้ควบคุมว่าผู้ใช้คนใดบ้างที่สามารถเห็นและเข้าถึงไฟล์ต่าง ๆ ได้**

#### เกณฑ์การยอมรับ
1. Endpoint `POST /files/{id}/permissions` กำหนดสิทธิ์ให้บทบาทเข้าถึงไฟล์เฉพาะ
2. Endpoint `DELETE /files/{id}/permissions/{roleName}` ยกเลิกสิทธิ์บทบาทจากไฟล์
3. Endpoint `GET /files/{id}/permissions` แสดงรายการบทบาททั้งหมดที่เข้าถึงไฟล์ได้
4. การดำเนินการสิทธิ์ตรวจสอบว่าบทบาทเป้าหมายมีอยู่ในฐานข้อมูล
5. การดำเนินการสิทธิ์ตรวจสอบว่าไฟล์เป้าหมายมีอยู่และผู้ใช้มีสิทธิ์เข้าถึง
6. หลักการ "ปลอดภัยไว้ก่อน": ไฟล์ใหม่จะไม่มีสิทธิ์ใด ๆ ยกเว้นสำหรับบทบาทของผู้อัปโหลด
7. ตาราง `FileRolePermissions` ถูกอัปเดตพร้อมการเชื่อมโยง Foreign Key ที่เหมาะสม
8. บันทึกการตรวจสอบ (Audit Trail) ถูกเก็บรักษาพร้อม Timestamp `grantedAt` สำหรับการติดตามสิทธิ์

### Story 3.4: การบังคับใช้การควบคุมการเข้าถึงและการกรองไฟล์

ในฐานะ **ผู้ใช้ API**
ฉันต้องการ **ให้การเข้าถึงไฟล์ถูกจำกัดตามบทบาทที่ฉันได้รับ**
เพื่อที่ **ฉันจะได้เห็นและเข้าถึงเฉพาะไฟล์ที่บทบาทของฉันได้รับอนุญาต**

#### เกณฑ์การยอมรับ
1. Endpoint `GET /files` กรองผลลัพธ์เพื่อแสดงเฉพาะไฟล์ที่บทบาทของผู้ใช้สามารถเข้าถึงได้
2. Endpoint `GET /files/{id}` ส่งคืน 404 สำหรับไฟล์ที่บทบาทของผู้ใช้ไม่สามารถเข้าถึงได้
3. การตรวจสอบสิทธิ์ไฟล์ถูกพัฒนาเป็นฟังก์ชัน Middleware ที่นำกลับมาใช้ใหม่ได้
4. การสืบค้นสิทธิ์ได้รับการปรับปรุงประสิทธิภาพโดยใช้ Prisma joins ระหว่างตาราง `Files` และ `FileRolePermissions`
5. ผู้ใช้สามารถเข้าถึงไฟล์ได้หาก **บทบาทใดบทบาทหนึ่ง** มีสิทธิ์ (ตรรกะแบบ OR ไม่ใช่ AND)
6. รายการไฟล์มีข้อมูลเมตาของสิทธิ์ที่ระบุระดับการเข้าถึงของผู้ใช้
7. ประสิทธิภาพได้รับการปรับปรุงสำหรับไฟล์จำนวนมากและการกำหนดบทบาทที่ซับซ้อน
8. ตรวจสอบความปลอดภัย: ไม่มีการรั่วไหลของข้อมูลเกี่ยวกับไฟล์ที่ผู้ใช้ไม่สามารถเข้าถึงได้

### Story 3.5: การสืบค้นไฟล์ตามบทบาทสำหรับผู้ดูแลระบบ

ในฐานะ **ผู้ดูแลระบบ**
ฉันต้องการ **สืบค้นไฟล์ตามรูปแบบการเข้าถึงของบทบาท**
เพื่อที่ **ฉันจะได้ตรวจสอบสิทธิ์และทำความเข้าใจว่าบทบาทใดสามารถเข้าถึงไฟล์ใดได้บ้าง**

#### เกณฑ์การยอมรับ
1. Endpoint `GET /roles/{roleName}/files` แสดงรายการไฟล์ทั้งหมดที่บทบาทเฉพาะเจาะจงเข้าถึงได้
2. Endpoint `GET /files/by-role` ยอมรับพารามิเตอร์ `?role=` สำหรับการกรองตามบทบาท
3. Endpoint ของผู้ดูแลระบบจำกัดเฉพาะผู้ใช้ที่มีบทบาท **"Boss"** เท่านั้น
4. ผลลัพธ์ประกอบด้วยข้อมูลเมตาไฟล์และ Timestamp ของการให้สิทธิ์
5. รองรับการแบ่งหน้า (Pagination) สำหรับชุดข้อมูลขนาดใหญ่พร้อมข้อมูลเมตาที่เหมาะสม
6. ประสิทธิภาพการสืบค้นได้รับการปรับปรุงด้วย Index ฐานข้อมูลที่เหมาะสม
7. รูปแบบการตอบกลับสอดคล้องกับ Endpoint แสดงรายการไฟล์อื่น ๆ
8. ความปลอดภัยตรวจสอบให้แน่ใจว่าผู้ใช้ที่ไม่ใช่ Boss ไม่สามารถเข้าถึงการสืบค้นของผู้ดูแลระบบได้

---

## Epic 4: เอกสาร API และความพร้อมใช้งานจริง

**เป้าหมายของ Epic**: จัดทำเอกสาร API ที่ครอบคลุม, จัดการข้อผิดพลาดและตรวจสอบข้อมูลอย่างมีประสิทธิภาพ, ตั้งค่าการผลิตให้เรียบร้อย, และทำให้ระบบพร้อมสำหรับการติดตั้งใช้งานด้วยความสามารถในการติดตามและการปฏิบัติงานที่เหมาะสม

### Story 4.1: จัดทำเอกสาร OpenAPI ที่สมบูรณ์

ในฐานะ **ผู้ใช้งาน API**
ฉันต้องการ **เอกสาร API ที่ครอบคลุมและใช้งานได้แบบโต้ตอบ**
เพื่อที่ **ฉันจะได้เข้าใจและนำไปใช้งานร่วมกับทุก endpoint ได้อย่างมีประสิทธิภาพ**

#### เกณฑ์การยอมรับ
1. ข้อมูลจำเพาะ OpenAPI มีทุก endpoint พร้อม Schema ของคำขอ/การตอบกลับที่สมบูรณ์
2. ทุก endpoint มีคำอธิบาย, พารามิเตอร์ และตัวอย่างคำขอ/การตอบกลับ
3. ข้อกำหนดการยืนยันตัวตนสำหรับแต่ละ endpoint ถูกระบุไว้อย่างชัดเจน
4. รูปแบบการตอบกลับเมื่อเกิดข้อผิดพลาดถูกจัดทำเป็นเอกสารพร้อมรหัสสถานะ HTTP ที่เป็นไปได้ทั้งหมด
5. อินเทอร์เฟซเอกสาร Scalar สามารถเข้าถึงได้ที่ `/docs` พร้อมตัวอย่างที่ใช้งานได้
6. Endpoint `OpenAPI.json` สามารถเข้าถึงได้ที่ `/openapi.json` สำหรับการเข้าถึงด้วยโปรแกรม
7. โมเดลคำขอ/การตอบกลับมีคำจำกัดความประเภทของ TypeScript
8. เอกสารแบบโต้ตอบอนุญาตให้ทดสอบ endpoint ได้โดยตรงจากเบราว์เซอร์

### Story 4.2: การจัดการข้อผิดพลาดและการตรวจสอบข้อมูลที่ครอบคลุม

ในฐานะ **ผู้ใช้งาน API**
ฉันต้องการ **การจัดการข้อผิดพลาดและการตรวจสอบข้อมูลนำเข้าที่สอดคล้องกัน**
เพื่อที่ **ฉันจะได้รับข้อมูลที่ชัดเจนเมื่อคำขอไม่สำเร็จหรือมีข้อมูลไม่ถูกต้อง**

#### เกณฑ์การยอมรับ
1. ทุก endpoint ของ API ใช้รูปแบบการตอบกลับข้อผิดพลาดที่สอดคล้องกันพร้อมรหัสข้อผิดพลาดและข้อความ
2. มีการตรวจสอบข้อมูลนำเข้าสำหรับทุก Request Body และ Query Parameter
3. การตรวจสอบการอัปโหลดไฟล์รวมถึงการจำกัดขนาด, ประเภทไฟล์ และความปลอดภัยของชื่อไฟล์
4. การละเมิดข้อจำกัดของฐานข้อมูลจะส่งคืนข้อความข้อผิดพลาดที่เข้าใจง่ายสำหรับผู้ใช้
5. ข้อผิดพลาดของบริการ MinIO ถูกดักจับอย่างถูกต้องและส่งคืนเป็น HTTP 500 พร้อมคำแนะนำในการลองใหม่
6. การจำกัดอัตราการส่งคำขอ (ถ้ามีการนำมาใช้) จะถูกจัดการอย่างเหมาะสมด้วยรหัสสถานะ HTTP ที่ถูกต้อง
7. ข้อผิดพลาดในการตรวจสอบคำขอจะส่งคืน HTTP 400 พร้อมรายละเอียดข้อผิดพลาดเฉพาะเจาะจง
8. Global Error Handler ดักจับข้อยกเว้นที่ไม่ได้รับการจัดการและส่งคืนข้อผิดพลาดที่ปลอดภัย

### Story 4.3: การตั้งค่าสำหรับการใช้งานจริงและการจัดการสภาพแวดล้อม

ในฐานะ **วิศวกร DevOps**
ฉันต้องการ **การตั้งค่าและการปรับใช้งานที่พร้อมสำหรับสภาพแวดล้อมจริง**
เพื่อที่ **ฉันจะได้ติดตั้งบริการนี้อย่างปลอดภัยในสภาพแวดล้อมต่าง ๆ**

#### เกณฑ์การยอมรับ
1. มีไฟล์การตั้งค่าเฉพาะสำหรับสภาพแวดล้อมการพัฒนา, Staging และ Production
2. ข้อมูลการตั้งค่าที่ละเอียดอ่อน (URL ฐานข้อมูล, ข้อมูล MinIO) ถูกดึงจากตัวแปร Environment
3. Docker Image ได้รับการปรับปรุงประสิทธิภาพสำหรับการผลิตพร้อมแนวทางปฏิบัติด้านความปลอดภัยที่เหมาะสม
4. Endpoint ตรวจสอบสถานะให้สถานะโดยละเอียดของส่วนประกอบทั้งหมด (ฐานข้อมูล, MinIO, Redis)
5. การจัดการการปิดระบบอย่างสง่างาม (Graceful Shutdown) สำหรับระบบจัดการ Container
6. การตั้งค่าการบันทึก (Logging) ที่เหมาะสมสำหรับการติดตามและแก้ปัญหาในการผลิต
7. ตั้งค่า Security Headers (CORS, Security Middleware) สำหรับการติดตั้งใช้งานจริง
8. เอกสารประกอบมีการอัปเดตพร้อมคำแนะนำการติดตั้ง Docker และรายการตัวแปร Environment

### Story 4.4: Unit Test และคุณภาพโค้ด

ในฐานะ **นักพัฒนาที่ดูแลโค้ด**
ฉันต้องการ **Unit Test ที่ครอบคลุมและการวัดคุณภาพโค้ด**
เพื่อที่ **ฉันจะได้แก้ไขและขยายระบบได้อย่างมั่นใจ**

#### เกณฑ์การยอมรับ
1. มี Unit Test สำหรับทุกฟังก์ชันของตรรกะทางธุรกิจและ endpoint ของ API
2. การดำเนินการฐานข้อมูลถูกทดสอบด้วยการจำลองหรือฐานข้อมูลทดสอบที่เหมาะสม
3. การเชื่อมต่อ MinIO ถูกทดสอบด้วยการจำลองบริการ MinIO
4. Middleware การยืนยันตัวตนถูกทดสอบด้วยสถานการณ์ Header ที่หลากหลาย
5. ตรรกะการบังคับใช้สิทธิ์ถูกทดสอบอย่างละเอียดด้วยการผสมผสานบทบาทที่แตกต่างกัน
6. รายงานความครอบคลุมของการทดสอบถูกสร้างและสามารถเข้าถึงได้
7. เปิดใช้งาน TypeScript strict mode โดยไม่มีข้อผิดพลาดด้านประเภท
8. การตรวจสอบโค้ด (Linting) และการจัดรูปแบบถูกตั้งค่าด้วยมาตรฐานที่สอดคล้องกัน

### Story 4.5: การตรวจสอบการผสานและการติดตั้งใช้งานจริงครั้งสุดท้าย

ในฐานะ **ผู้มีส่วนได้ส่วนเสียในโครงการ**
ฉันต้องการ **การตรวจสอบระบบที่สมบูรณ์ในสภาพแวดล้อมที่เหมือนกับการผลิต**
เพื่อที่ **ฉันจะได้ยืนยันว่าระบบพร้อมสำหรับการใช้งานจริง**

#### เกณฑ์การยอมรับ
1. มีการทดสอบเวิร์กโฟลว์แบบ End-to-End: การอัปโหลดไฟล์, การจัดการสิทธิ์, การเข้าถึงตามบทบาท
2. การติดตั้งด้วย Docker Compose ถูกทดสอบร่วมกับทุกบริการ (PostgreSQL, Redis, MinIO)
3. การทดสอบประสิทธิภาพภายใต้ปริมาณงานที่คาดไว้พร้อมเวลาตอบสนองที่เหมาะสม
4. การตรวจสอบความปลอดภัย: การจำกัดบทบาท, การบังคับใช้สิทธิ์, การตรวจสอบข้อมูลนำเข้า
5. ตรวจสอบเอกสารที่สมบูรณ์พร้อมคำแนะนำการตั้งค่าและตัวอย่าง API
6. Checklist การติดตั้งใช้งานจริงเสร็จสมบูรณ์พร้อมขั้นตอนการปฏิบัติงาน
7. ขั้นตอนการสำรองและกู้คืนข้อมูลสำหรับฐานข้อมูลและพื้นที่จัดเก็บไฟล์ถูกจัดทำเป็นเอกสาร
8. มีคำแนะนำเกี่ยวกับการติดตามและการแจ้งเตือนระบบสำหรับทีมปฏิบัติการ

---

## รายงานผลการตรวจสอบ

_จะถูกกรอกหลังจาก PM ตรวจสอบเสร็จสิ้น_

---

## ขั้นตอนต่อไป

### คำแนะนำสำหรับผู้เชี่ยวชาญด้าน UX
ไม่มี - นี่คือบริการ API สำหรับส่วน Backend เท่านั้น ไม่มีส่วนประกอบที่เป็น User Interface

### คำแนะนำสำหรับสถาปนิก
เอกสาร PRD นี้สมบูรณ์และพร้อมสำหรับการออกแบบสถาปัตยกรรมแล้ว โปรดเริ่มสร้างสถาปัตยกรรมโดยใช้เอกสารนี้เป็นข้อมูลพื้นฐาน โดยให้ความสำคัญกับ:

- **สถาปัตยกรรมที่เน้นฐานข้อมูลเป็นหลัก** โดยใช้การออกแบบ 3 ตาราง (Files, Roles, FileRolePermissions)
- **การใช้ RBAC ที่เน้นความปลอดภัยเป็นอันดับแรก** ด้วยค่าเริ่มต้นที่จำกัด
- **การผสานการทำงานกับ Caddy forward_auth** เพื่อการยืนยันตัวตนที่ราบรื่น
- **การปรับปรุงประสิทธิภาพของ Tech Stack** ที่ใช้ ElysiaJS + Bun + Prisma
- **กลยุทธ์การติดตั้งใช้งานแบบ Docker Container เดียว**
- **รูปแบบการพัฒนาที่พร้อมใช้งานจริง** และเหมาะสมกับนักศึกษาฝึกงาน

PRD นี้เน้นเรื่องความปลอดภัย, ความเรียบง่าย, และความพร้อมใช้งานจริง โดยยังคงขอบเขตที่เหมาะสมสำหรับนักศึกษาฝึกงาน 1 คนที่สามารถทำได้เสร็จใน 4 สัปดาห์ (คาดว่าน่าจะประมาณ 3 สัปดาห์)
